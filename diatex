#!/usr/bin/ruby
# rubocop:disable Metrics/LineLength

require 'calculus'
require 'octokit'
require 'digest'
require 'net/http'
require 'tempfile'

REGEX = %r{
  ^(?<!<!---)                   # Make sure its not a comment
  \n                            # Match a new line
  (?<declaration>
    ```(?<type>latex|diagram)   # Match the content of latex or diagram
    \n
    (.|\n)*?                    # Non-greedy match all and new line, for actual declaration
    \n
    ```
  )
  \n?
  (?!--->)$                     # Make sure its really not a comment
}x

GITHUB_CLIENT = Octokit::Client.new(access_token: ENV['GITHUB_ACCESS_TOKEN'])

def create_remote_image(client: raise, image_path: raise, remote_path: raise)
  remote_image_path = "images/md/#{remote_path}.png"
  url = "#{ENV['GITHUB_PAGES_URL']}/#{remote_image_path}"

  # Make sure the image doesn't already exist
  # Since we do a hash of the text contents, that can be considered a cache
  res = Net::HTTP.get_response(URI(url))
  if res.code == '404'
    client.create_contents(
      ENV['GITHUB_REPO'],
      remote_image_path,
      "Adding Image #{remote_path}",
      branch: ENV['GITHUB_BRANCH'],
      file: image_path
    )
  end

  url
end

def replacement_text(match, content, type)
  # The etag can be cosntructed from the hexdigest of the content, this is used for a cache
  etag = Digest::SHA256.hexdigest(content)
  file_path = case type
              when 'latex'
                Calculus::Expression.new(content).to_png
              when 'diagram'
                file = Tempfile.new([etag, '.mmd'])
                begin
                  # Write contents of the diagram to the mmd file and flush the buffer
                  file.write(content)
                  file.flush
                  # Pipe out to the mermaid program to convert to a diagram image
                  system("mermaid #{file.path} --png --outputDir /tmp")
                  "/tmp/#{File.basename(file)}.png"
                ensure
                  file.close
                  file.unlink
                end
              end

  # Markdown can't render Base64 images, and we can't guarantee paths will exist properly
  # So upload it to a Git Repo with GH Pages and return the to inject instead
  url = create_remote_image(client: GITHUB_CLIENT, image_path: file_path, remote_path: etag)
  # The replacement text will be HTML commented blocks, followed by a markdown image
  "\n<!---\n#{match.strip}\n--->\n![#{type} image](#{url})\n"
end

# Read each file as and replace the content specified by the REGEX
def parse_file(file)
  File.read(file).gsub(REGEX) do |match|
    r = Regexp.last_match
    content = match.gsub(/```\S*/, '').strip # Remove the backticks and new lines
    replacement_text(match, content, r['type'].downcase)
  end
end

# Make sure the environment is setup properly
def check_env(*var_names)
  messages = var_names.collect do |var_name|
    "#{var_name} was not set in env" if ENV[var_name].nil?
  end.compact
  raise messages.join("\n") unless messages.empty?
end
check_env('GITHUB_ACCESS_TOKEN', 'GITHUB_PAGES_URL', 'GITHUB_REPO', 'GITHUB_BRANCH')

# Make sure directory is provide and exists as a directory
raise 'Did not provide a path as an argument' if ARGV[0].nil?
raise "Path #{ARGV[0]} did not exist as a directory" if !File.exist?(ARGV[0]) || !File.directory?(ARGV[0])

# Parse all markdown files in specified directory
Dir["#{ARGV[0]}/**/*.md"].each do |file|
  printf file
  new_content = parse_file(file)
  File.write(file, new_content)
  printf " >>> Done\n"
end

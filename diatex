#!/usr/bin/ruby
# rubocop:disable Metrics/LineLength

require 'octokit'
require 'digest'
require 'net/http'
require 'tempfile'

REGEX = %r{
  ^(?<!<!---)                   # Make sure its not a comment
  \n                            # Match a new line
  (?<declaration>
    ```(?<type>latex|diagram)   # Match the content of latex or diagram
    \n
    (.|\n)*?                    # Non-greedy match all and new line, for actual declaration
    \n
    ```
  )
  \n?
  (?!--->)$                     # Make sure its really not a comment
}x

GITHUB_CLIENT = Octokit::Client.new(access_token: ENV['GITHUB_ACCESS_TOKEN'])

def remote_image_url(etag)
  remote_image_path = "images/md/#{etag}.png"
  "#{ENV['GITHUB_PAGES_URL']}/#{remote_image_path}"
end

def remote_image_exists?(etag)
  url = remote_image_url(etag)
  res = Net::HTTP.get_response(URI(url))
  res.code == '200'
end

def create_remote_image(client: raise, image_path: raise, etag: raise)
  # Make sure the image doesn't already exist
  # Since we do a hash of the text contents, that can be considered a cache
  unless remote_image_exists?(etag)
    client.create_contents(
      ENV['GITHUB_REPO'],
      "images/md/#{etag}.png",
      "Adding Image #{etag}",
      branch: ENV['GITHUB_BRANCH'],
      file: image_path
    )
  end

  remote_image_url(etag)
end

def latex_image(content, etag)
  escaped_content = content.gsub(' ', '&space;').tr('(', '\(').tr(')', '\)')
  url = 'https://latex.codecogs.com/gif.latex?' + escaped_content
  uri = URI(url)

  file = Tempfile.new([etag, '.png'])
  file.binmode
  file.write(Net::HTTP.get(uri))
  file.flush
  file.path
end

def diagram_image(content, etag)
  file = Tempfile.new([etag, '.mmd'])
  begin
    # Write contents of the diagram to the mmd file and flush the buffer
    file.write(content)
    file.flush
    # Pipe out to the mermaid program to convert to a diagram image
    system("mermaid #{file.path} --png --outputDir /tmp")
    "/tmp/#{File.basename(file)}.png"
  ensure
    file.close
    file.unlink
  end
end

def replacement_text(match, content, type)
  # The etag can be cosntructed from the hexdigest of the content, this is used for a cache
  etag = Digest::SHA256.hexdigest(content)
  file_path = case type
              when 'latex'
                latex_image(content, etag)
              when 'diagram'
                diagram_image(content, etag)
              end

  begin
    # Markdown can't render Base64 images, and we can't guarantee paths will exist properly
    # So upload it to a Git Repo with GH Pages and return the to inject instead
    url = create_remote_image(client: GITHUB_CLIENT, image_path: file_path, etag: etag)
    # The replacement text will be HTML commented blocks, followed by a markdown image
    "\n<!---\n#{match.strip}\n--->\n![#{type} image](#{url})\n"
  ensure
    FileUtils.rm_rf(file_path)
  end
end

# Read each file as and replace the content specified by the REGEX
def parse_file(file)
  File.read(file).gsub(REGEX) do |match|
    r = Regexp.last_match
    content = match.gsub(/```\S*/, '').strip # Remove the backticks and new lines
    replacement_text(match, content, r['type'].downcase)
  end
end

# Make sure the environment is setup properly
def check_env(*var_names)
  messages = var_names.collect do |var_name|
    "#{var_name} was not set in env" if ENV[var_name].nil?
  end.compact
  raise messages.join("\n") unless messages.empty?
end
check_env('GITHUB_ACCESS_TOKEN', 'GITHUB_PAGES_URL', 'GITHUB_REPO', 'GITHUB_BRANCH')

# Make sure directory is provide and exists as a directory
raise 'Did not provide a path as an argument' if ARGV[0].nil?
raise "Path #{ARGV[0]} did not exist as a directory" if !File.exist?(ARGV[0]) || !File.directory?(ARGV[0])

# Parse all markdown files in specified directory
Dir["#{ARGV[0]}/**/*.md"].each do |file|
  printf file
  new_content = parse_file(file)
  File.write(file, new_content)
  printf " >>> Done\n"
end
